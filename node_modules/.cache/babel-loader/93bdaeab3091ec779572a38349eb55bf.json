{"ast":null,"code":"import React from 'react';\nimport BoardRow from './Boardrow';\n\nfunction getWordGrid(wordList, rowCount, colCount) {\n  let grid = []; //creating empty grid\n\n  for (let r = 0; r < rowCount; r++) {\n    let col = [];\n\n    for (let c = 0; c < colCount; c++) {\n      col.push('');\n    }\n\n    grid.push(col);\n  } // fill with  words from word list\n\n\n  for (let w = 0; w < wordList.length; w++) {\n    let word = wordList[w];\n    let randomRow = getRandomInt(0, rowCount - 1);\n    let colStart = getRandomInt(0, colCount - word.length - 1);\n    console.log(\"placing \" + word + \" in \" + randomRow + \" \" + colStart);\n\n    for (let i = 0; i < word.length; i++) {\n      let letter = word[i];\n      grid[randomRow][colStart + i] = letter.toUpperCase();\n    }\n  } // fill remaining empty cells with random letters\n\n\n  const alphabet = \"abcdefghijklmnopqrstuvwxyz\";\n\n  for (let r = 0; r < rowCount; r++) {\n    for (let c = 0; c < colCount; c++) {\n      if (grid[r][c] === '') {\n        const randomCharacter = alphabet[Math.floor(Math.random() * alphabet.length)];\n        grid[r][c] = randomCharacter;\n      }\n    }\n  }\n\n  return grid;\n}\n/**\n * Returns a random integer between min (inclusive) and max .\n * The value is no lower than min (or the next integer greater than min\n * if min isn't an integer) and no greater than max (or the next integer\n * lower than max if max isn't an integer).\n * Using Math.round() will give you a non-uniform distribution!\n */\n\n\nfunction getRandomInt(min, max) {\n  min = Math.ceil(min);\n  max = Math.floor(max);\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n}\n\nmodule.exports = {\n  getWordGrid\n};","map":{"version":3,"sources":["/Users/yara/Desktop/WebDevelopment/word-search/src/logic/app.js"],"names":["React","BoardRow","getWordGrid","wordList","rowCount","colCount","grid","r","col","c","push","w","length","word","randomRow","getRandomInt","colStart","console","log","i","letter","toUpperCase","alphabet","randomCharacter","Math","floor","random","min","max","ceil","module","exports"],"mappings":"AAAA,OAAOA,KAAP,MAAkB,OAAlB;AACA,OAAOC,QAAP,MAAqB,YAArB;;AAEA,SAASC,WAAT,CAAqBC,QAArB,EAA+BC,QAA/B,EAAyCC,QAAzC,EAAmD;AAChD,MAAIC,IAAI,GAAG,EAAX,CADgD,CAGhD;;AACC,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,QAApB,EAA8BG,CAAC,EAA/B,EAAmC;AAChC,QAAIC,GAAG,GAAG,EAAV;;AACA,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGJ,QAApB,EAA8BI,CAAC,EAA/B,EAAmC;AAC7BD,MAAAA,GAAG,CAACE,IAAJ,CAAS,EAAT;AACL;;AACDJ,IAAAA,IAAI,CAACI,IAAL,CAAUF,GAAV;AACF,GAV8C,CAY/C;;;AACA,OAAM,IAAIG,CAAC,GAAG,CAAd,EAAiBA,CAAC,GAAGR,QAAQ,CAACS,MAA9B,EAAsCD,CAAC,EAAvC,EAA2C;AACzC,QAAIE,IAAI,GAAGV,QAAQ,CAACQ,CAAD,CAAnB;AACA,QAAIG,SAAS,GAAGC,YAAY,CAAC,CAAD,EAAIX,QAAQ,GAAG,CAAf,CAA5B;AACA,QAAIY,QAAQ,GAAGD,YAAY,CAAC,CAAD,EAAIV,QAAQ,GAAGQ,IAAI,CAACD,MAAhB,GAAyB,CAA7B,CAA3B;AACAK,IAAAA,OAAO,CAACC,GAAR,CAAY,aAAaL,IAAb,GAAoB,MAApB,GAA6BC,SAA7B,GAAyC,GAAzC,GAA+CE,QAA3D;;AAEA,SAAK,IAAIG,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGN,IAAI,CAACD,MAAzB,EAAiCO,CAAC,EAAlC,EAAsC;AACpC,UAAIC,MAAM,GAAGP,IAAI,CAACM,CAAD,CAAjB;AACEb,MAAAA,IAAI,CAACQ,SAAD,CAAJ,CAAgBE,QAAQ,GAAGG,CAA3B,IAAgCC,MAAM,CAACC,WAAP,EAAhC;AACH;AACF,GAvB8C,CAwB/C;;;AACA,QAAMC,QAAQ,GAAG,4BAAjB;;AAEA,OAAK,IAAIf,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,QAApB,EAA8BG,CAAC,EAA/B,EAAmC;AAC/B,SAAK,IAAIE,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGJ,QAApB,EAA8BI,CAAC,EAA/B,EAAmC;AACjC,UAAKH,IAAI,CAACC,CAAD,CAAJ,CAAQE,CAAR,MAAe,EAApB,EAAyB;AACvB,cAAMc,eAAe,GAAGD,QAAQ,CAACE,IAAI,CAACC,KAAL,CAAWD,IAAI,CAACE,MAAL,KAAgBJ,QAAQ,CAACV,MAApC,CAAD,CAAhC;AACAN,QAAAA,IAAI,CAACC,CAAD,CAAJ,CAAQE,CAAR,IAAac,eAAb;AACD;AACJ;AACF;;AAED,SAAOjB,IAAP;AACH;AACD;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASS,YAAT,CAAsBY,GAAtB,EAA2BC,GAA3B,EAAgC;AAC5BD,EAAAA,GAAG,GAAGH,IAAI,CAACK,IAAL,CAAUF,GAAV,CAAN;AACAC,EAAAA,GAAG,GAAGJ,IAAI,CAACC,KAAL,CAAWG,GAAX,CAAN;AACA,SAAOJ,IAAI,CAACC,KAAL,CAAWD,IAAI,CAACE,MAAL,MAAiBE,GAAG,GAAGD,GAAN,GAAY,CAA7B,CAAX,IAA8CA,GAArD;AACH;;AAGDG,MAAM,CAACC,OAAP,GAAiB;AAAE7B,EAAAA;AAAF,CAAjB","sourcesContent":["import React from 'react';\nimport BoardRow from './Boardrow';\n\nfunction getWordGrid(wordList, rowCount, colCount) {\n   let grid = []\n   \n   //creating empty grid\n    for (let r = 0; r < rowCount; r++) {\n       let col = []; \n       for (let c = 0; c < colCount; c++) {\n             col.push('');\n       } \n       grid.push(col);\n    } \n    \n    // fill with  words from word list\n    for ( let w = 0; w < wordList.length; w++) {\n      let word = wordList[w];\n      let randomRow = getRandomInt(0, rowCount - 1);\n      let colStart = getRandomInt(0, colCount - word.length - 1);\n      console.log(\"placing \" + word + \" in \" + randomRow + \" \" + colStart);\n      \n      for (let i = 0; i < word.length; i++) {\n        let letter = word[i];\n          grid[randomRow][colStart + i] = letter.toUpperCase();\n      }\n    }      \n    // fill remaining empty cells with random letters\n    const alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n      \n    for (let r = 0; r < rowCount; r++) {\n        for (let c = 0; c < colCount; c++) {\n          if ( grid[r][c] === '' ) {\n            const randomCharacter = alphabet[Math.floor(Math.random() * alphabet.length)]\n            grid[r][c] = randomCharacter;\n          }\n      }\n    }\n\n    return grid;\n}\n/**\n * Returns a random integer between min (inclusive) and max .\n * The value is no lower than min (or the next integer greater than min\n * if min isn't an integer) and no greater than max (or the next integer\n * lower than max if max isn't an integer).\n * Using Math.round() will give you a non-uniform distribution!\n */\nfunction getRandomInt(min, max) {\n    min = Math.ceil(min);\n    max = Math.floor(max);\n    return Math.floor(Math.random() * (max - min + 1)) + min;\n}\n\n\nmodule.exports = { getWordGrid };"]},"metadata":{},"sourceType":"module"}